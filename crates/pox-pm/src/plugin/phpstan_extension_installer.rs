//! PHPStan Extension Installer plugin.
//!
//! This is a native Rust port of phpstan/extension-installer.
//! It auto-discovers PHPStan extensions and generates a config file
//! so PHPStan can automatically load them without manual configuration.

use std::collections::HashMap;
use std::path::Path;
use std::sync::Arc;

use crate::composer::Composer;
use crate::event::{ComposerEvent, EventListener, EventType, PostAutoloadDumpEvent};
use crate::json::ComposerJson;
use crate::package::Package;
use crate::Result;

/// The package name that triggers this plugin.
pub const PACKAGE_NAME: &str = "phpstan/extension-installer";

/// The generated PHP config file template
const GENERATED_CONFIG_TEMPLATE: &str = r#"<?php declare(strict_types = 1);

namespace PHPStan\ExtensionInstaller;

/**
 * This class is generated by phpstan/extension-installer.
 * @internal
 */
final class GeneratedConfig
{

	public const EXTENSIONS = %EXTENSIONS%;

	public const NOT_INSTALLED = %NOT_INSTALLED%;

	/** @var string|null */
	public const PHPSTAN_VERSION_CONSTRAINT = %PHPSTAN_VERSION_CONSTRAINT%;

	private function __construct()
	{
	}

}
"#;

/// Packages that should be ignored when checking for "phpstan" in name
const IGNORED_PHPSTAN_PACKAGES: &[&str] = &[
    "phpstan/phpstan",
    "phpstan/phpstan-shim",
    "phpstan/phpdoc-parser",
    "phpstan/extension-installer",
];

/// PHPStan Extension Installer plugin - implements EventListener directly.
pub struct PhpstanExtensionInstallerPlugin;

impl EventListener for PhpstanExtensionInstallerPlugin {
    fn handle(&self, event: &dyn ComposerEvent, composer: &Composer) -> anyhow::Result<i32> {
        if event.event_type() != EventType::PostAutoloadDump {
            return Ok(0);
        }

        let Some(e) = event.as_any().downcast_ref::<PostAutoloadDumpEvent>() else {
            return Ok(0);
        };

        // Check if our package is installed
        let is_installed = e.packages.iter().any(|p| p.name == PACKAGE_NAME);
        if !is_installed {
            return Ok(0);
        }

        self.post_autoload_dump(
            &composer.vendor_dir(),
            &composer.composer_json,
            &e.packages,
        )?;

        Ok(0)
    }

    fn priority(&self) -> i32 {
        -10
    }
}

impl PhpstanExtensionInstallerPlugin {
    fn post_autoload_dump(
        &self,
        vendor_dir: &Path,
        composer_json: &ComposerJson,
        installed_packages: &[Arc<Package>],
    ) -> Result<()> {
        // Get ignore list from composer.json extra
        let ignore_list = get_ignore_list(&composer_json.extra);

        // Collect extension data
        let mut extensions: HashMap<String, ExtensionData> = HashMap::new();
        let mut not_installed: HashMap<String, String> = HashMap::new();

        for package in installed_packages {
            // Read the package's composer.json to check for phpstan config
            let package_composer_path = vendor_dir.join(&package.name).join("composer.json");

            let package_json: Option<ComposerJson> = if package_composer_path.exists() {
                std::fs::read_to_string(&package_composer_path)
                    .ok()
                    .and_then(|content| serde_json::from_str(&content).ok())
            } else {
                None
            };

            let package_type: Option<&str> = package_json.as_ref()
                .map(|pj| pj.package_type.as_str())
                .filter(|s| !s.is_empty());

            let phpstan_extra = package_json.as_ref()
                .and_then(|pj| pj.extra.get("phpstan"));

            // Check if this is a phpstan extension
            let is_extension = package_type == Some("phpstan-extension") || phpstan_extra.is_some();

            if !is_extension {
                // Check if package name contains "phpstan" but isn't supported
                if package.name.contains("phpstan") && !IGNORED_PHPSTAN_PACKAGES.contains(&package.name.as_str()) {
                    not_installed.insert(package.name.clone(), package.version.to_string());
                }
                continue;
            }

            // Check if package is in ignore list
            if ignore_list.contains(&package.name) {
                continue;
            }

            // Get the install path
            let install_path = vendor_dir.join(&package.name);
            let absolute_install_path = install_path.canonicalize()
                .unwrap_or_else(|_| install_path.clone());

            // Calculate relative path from the GeneratedConfig.php location
            let generated_config_dir = vendor_dir.join("phpstan/extension-installer/src");
            let relative_install_path = pathdiff::diff_paths(&absolute_install_path, &generated_config_dir)
                .map(|p| p.to_string_lossy().to_string())
                .unwrap_or_else(|| absolute_install_path.to_string_lossy().to_string());

            extensions.insert(package.name.clone(), ExtensionData {
                install_path: absolute_install_path.to_string_lossy().to_string(),
                relative_install_path,
                extra: phpstan_extra.cloned(),
                version: package.version.to_string(),
            });
        }

        // Generate the config file
        let generated_config_path = vendor_dir
            .join("phpstan")
            .join("extension-installer")
            .join("src")
            .join("GeneratedConfig.php");

        // Only write if the directory exists (package is installed)
        if let Some(parent) = generated_config_path.parent() {
            if parent.exists() {
                let content = generate_config_content(&extensions, &not_installed);

                // Only write if content has changed
                let current_content = std::fs::read_to_string(&generated_config_path).ok();
                if current_content.as_ref() != Some(&content) {
                    std::fs::write(&generated_config_path, &content)?;
                }
            }
        }

        Ok(())
    }
}

/// Extension data for a PHPStan extension package
struct ExtensionData {
    install_path: String,
    relative_install_path: String,
    extra: Option<serde_json::Value>,
    version: String,
}

/// Get the ignore list from composer.json extra
fn get_ignore_list(extra: &serde_json::Value) -> Vec<String> {
    extra
        .get("phpstan/extension-installer")
        .and_then(|v| v.get("ignore"))
        .and_then(|v| v.as_array())
        .map(|arr| {
            arr.iter()
                .filter_map(|v| v.as_str().map(String::from))
                .collect()
        })
        .unwrap_or_default()
}

/// Generate the PHP config file content
fn generate_config_content(
    extensions: &HashMap<String, ExtensionData>,
    not_installed: &HashMap<String, String>,
) -> String {
    // Sort extensions by name for consistent output
    let mut sorted_extensions: Vec<_> = extensions.iter().collect();
    sorted_extensions.sort_by(|a, b| a.0.cmp(b.0));

    // Generate extensions array
    let extensions_php = if sorted_extensions.is_empty() {
        "[]".to_string()
    } else {
        let mut parts = vec!["array(".to_string()];
        for (name, data) in sorted_extensions {
            parts.push(format!(
                "  {} => array(",
                php_var_export_string(name)
            ));
            parts.push(format!(
                "    'install_path' => {},",
                php_var_export_string(&data.install_path)
            ));
            parts.push(format!(
                "    'relative_install_path' => {},",
                php_var_export_string(&data.relative_install_path)
            ));

            // Handle extra field
            if let Some(extra) = &data.extra {
                parts.push(format!(
                    "    'extra' => {},",
                    php_var_export(extra)
                ));
            } else {
                parts.push("    'extra' => NULL,".to_string());
            }

            parts.push(format!(
                "    'version' => {},",
                php_var_export_string(&data.version)
            ));
            parts.push("    'phpstanVersionConstraint' => NULL,".to_string());
            parts.push("  ),".to_string());
        }
        parts.push(")".to_string());
        parts.join("\n")
    };

    // Generate not_installed array
    let mut sorted_not_installed: Vec<_> = not_installed.iter().collect();
    sorted_not_installed.sort_by(|a, b| a.0.cmp(b.0));

    let not_installed_php = if sorted_not_installed.is_empty() {
        "[]".to_string()
    } else {
        let items: Vec<String> = sorted_not_installed
            .iter()
            .map(|(name, version)| format!("  {} => {}", php_var_export_string(name), php_var_export_string(version)))
            .collect();
        format!("array(\n{},\n)", items.join(",\n"))
    };

    GENERATED_CONFIG_TEMPLATE
        .replace("%EXTENSIONS%", &extensions_php)
        .replace("%NOT_INSTALLED%", &not_installed_php)
        .replace("%PHPSTAN_VERSION_CONSTRAINT%", "NULL")
}

/// Convert a Rust string to PHP var_export format
fn php_var_export_string(s: &str) -> String {
    let escaped = s.replace('\\', "\\\\").replace('\'', "\\'");
    format!("'{}'", escaped)
}

/// Convert a serde_json::Value to PHP var_export format
fn php_var_export(value: &serde_json::Value) -> String {
    match value {
        serde_json::Value::Null => "NULL".to_string(),
        serde_json::Value::Bool(b) => if *b { "true" } else { "false" }.to_string(),
        serde_json::Value::Number(n) => n.to_string(),
        serde_json::Value::String(s) => php_var_export_string(s),
        serde_json::Value::Array(arr) => {
            if arr.is_empty() {
                "array()".to_string()
            } else {
                let items: Vec<String> = arr.iter().map(php_var_export).collect();
                format!("array({})", items.join(", "))
            }
        }
        serde_json::Value::Object(obj) => {
            if obj.is_empty() {
                "array()".to_string()
            } else {
                let items: Vec<String> = obj
                    .iter()
                    .map(|(k, v)| format!("{} => {}", php_var_export_string(k), php_var_export(v)))
                    .collect();
                format!("array({})", items.join(", "))
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_php_var_export_string() {
        assert_eq!(php_var_export_string("hello"), "'hello'");
        assert_eq!(php_var_export_string("it's"), "'it\\'s'");
        assert_eq!(php_var_export_string("path\\to"), "'path\\\\to'");
    }

    #[test]
    fn test_get_ignore_list() {
        let extra = serde_json::json!({
            "phpstan/extension-installer": {
                "ignore": ["phpstan/phpstan-phpunit", "phpstan/phpstan-doctrine"]
            }
        });

        let ignore = get_ignore_list(&extra);
        assert_eq!(ignore.len(), 2);
        assert!(ignore.contains(&"phpstan/phpstan-phpunit".to_string()));
        assert!(ignore.contains(&"phpstan/phpstan-doctrine".to_string()));
    }

    #[test]
    fn test_get_ignore_list_empty() {
        let extra = serde_json::json!({});
        let ignore = get_ignore_list(&extra);
        assert!(ignore.is_empty());
    }

    #[test]
    fn test_generate_empty_config() {
        let extensions = HashMap::new();
        let not_installed = HashMap::new();
        let content = generate_config_content(&extensions, &not_installed);

        assert!(content.contains("EXTENSIONS = []"));
        assert!(content.contains("NOT_INSTALLED = []"));
        assert!(content.contains("PHPSTAN_VERSION_CONSTRAINT = NULL"));
    }
}
