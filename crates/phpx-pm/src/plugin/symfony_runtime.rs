//! Symfony Runtime plugin - generates autoload_runtime.php.
//!
//! This is a native Rust port of symfony/runtime's ComposerPlugin.
//! When symfony/runtime is installed, this plugin generates the
//! autoload_runtime.php file that enables the Symfony Runtime component.

use std::path::Path;

use crate::composer::Composer;
use crate::event::{ComposerEvent, EventListener, EventType, PostAutoloadDumpEvent};
use crate::json::ComposerJson;
use crate::Result;

/// The package name that triggers this plugin.
pub const PACKAGE_NAME: &str = "symfony/runtime";

/// The autoload_runtime.php template.
/// This matches the template from symfony/runtime.
const AUTOLOAD_RUNTIME_TEMPLATE: &str = r#"<?php

// autoload_runtime.php @generated by Symfony Runtime

if (true === (require_once __DIR__.'/autoload.php') || empty($_SERVER['SCRIPT_FILENAME'])) {
    return;
}

$app = require $_SERVER['SCRIPT_FILENAME'];

if (!is_object($app)) {
    throw new TypeError(sprintf('Invalid return value: callable object expected, "%s" returned from "%s".', get_debug_type($app), $_SERVER['SCRIPT_FILENAME']));
}

$runtime = $_SERVER['APP_RUNTIME'] ?? $_ENV['APP_RUNTIME'] ?? %runtime_class%;
$runtime = new $runtime(($_SERVER['APP_RUNTIME_OPTIONS'] ?? $_ENV['APP_RUNTIME_OPTIONS'] ?? []) + %runtime_options%);

[$app, $args] = $runtime
    ->getResolver($app)
    ->resolve();

$app = $app(...$args);

exit(
    $runtime
        ->getRunner($app)
        ->run()
);
"#;

/// Symfony Runtime plugin - implements EventListener directly.
pub struct SymfonyRuntimePlugin;

impl EventListener for SymfonyRuntimePlugin {
    fn handle(&self, event: &dyn ComposerEvent, composer: &Composer) -> anyhow::Result<i32> {
        if event.event_type() != EventType::PostAutoloadDump {
            return Ok(0);
        }

        let Some(e) = event.as_any().downcast_ref::<PostAutoloadDumpEvent>() else {
            return Ok(0);
        };

        // Check if our package is installed
        let is_installed = e.packages.iter().any(|p| p.name == PACKAGE_NAME);
        if !is_installed {
            return Ok(0);
        }

        self.post_autoload_dump(
            &composer.vendor_dir(),
            &composer.working_dir,
            &composer.composer_json,
        )?;

        Ok(0)
    }

    fn priority(&self) -> i32 {
        -10
    }
}

impl SymfonyRuntimePlugin {
    fn post_autoload_dump(
        &self,
        vendor_dir: &Path,
        project_dir: &Path,
        composer_json: &ComposerJson,
    ) -> Result<()> {
        let autoload_file = vendor_dir.join("autoload.php");

        // Check if autoload.php exists
        if !autoload_file.exists() {
            return Ok(());
        }

        // Get runtime configuration from extra.runtime
        let runtime_extra = composer_json.extra.get("runtime");

        // If runtime is explicitly set to false, skip generation
        if let Some(serde_json::Value::Bool(false)) = runtime_extra {
            return Ok(());
        }

        // Get the runtime options (or empty object)
        let extra = runtime_extra
            .cloned()
            .unwrap_or(serde_json::Value::Object(serde_json::Map::new()));

        // Check for custom autoload_template
        let autoload_template_path = extra.get("autoload_template").and_then(|v| v.as_str());

        let template_content = if let Some(template_path) = autoload_template_path {
            // Resolve the template path
            let resolved_path = if Path::new(template_path).is_absolute() {
                template_path.to_string()
            } else {
                project_dir.join(template_path).to_string_lossy().to_string()
            };

            // Read the custom template
            std::fs::read_to_string(&resolved_path).map_err(|_| {
                crate::error::ComposerError::Config(format!(
                    "File \"{}\" defined under \"extra.runtime.autoload_template\" in your composer.json file not found.",
                    template_path
                ))
            })?
        } else {
            AUTOLOAD_RUNTIME_TEMPLATE.to_string()
        };

        // Calculate project_dir relative path from vendor_dir
        let project_dir_code = self.calculate_project_dir_code(vendor_dir, project_dir)?;

        // Get runtime class (default: Symfony\Component\Runtime\SymfonyRuntime)
        let runtime_class = extra
            .get("class")
            .and_then(|v| v.as_str())
            .unwrap_or("Symfony\\Component\\Runtime\\SymfonyRuntime");

        // Build runtime options, excluding 'class' and 'autoload_template'
        let runtime_options = self.build_runtime_options(&extra, &project_dir_code);

        // Replace placeholders in template
        let code = template_content
            .replace("%project_dir%", &project_dir_code)
            .replace("%runtime_class%", &php_var_export_string(runtime_class))
            .replace("%runtime_options%", &runtime_options);

        // Write to autoload_runtime.php
        let output_path = vendor_dir.join("autoload_runtime.php");

        // Only write if content has changed
        let current_content = std::fs::read_to_string(&output_path).ok();
        if current_content.as_ref() != Some(&code) {
            std::fs::write(&output_path, &code)?;
        }

        Ok(())
    }

    /// Calculate the PHP code for project_dir relative to vendor_dir.
    fn calculate_project_dir_code(&self, vendor_dir: &Path, project_dir: &Path) -> Result<String> {
        // Get canonical paths for comparison
        let vendor_canonical = vendor_dir.canonicalize().unwrap_or_else(|_| vendor_dir.to_path_buf());
        let project_canonical = project_dir.canonicalize().unwrap_or_else(|_| project_dir.to_path_buf());

        // Calculate relative path from vendor_dir to project_dir
        let relative = pathdiff::diff_paths(&project_canonical, &vendor_canonical)
            .unwrap_or_else(|| project_canonical.clone());

        let relative_str = relative.to_string_lossy();

        // Count nesting level (number of ../ at the start)
        let mut nesting_level = 0;
        let mut remaining = relative_str.as_ref();

        while remaining.starts_with("../") || remaining == ".." {
            nesting_level += 1;
            if remaining == ".." {
                remaining = "";
                break;
            }
            remaining = &remaining[3..];
        }

        // Build the PHP code
        if nesting_level == 0 {
            // Project is under vendor (unlikely but possible)
            if remaining.is_empty() || remaining == "." {
                Ok("__DIR__".to_string())
            } else {
                Ok(format!("__DIR__.{}", php_var_export_string(&format!("/{}", remaining))))
            }
        } else {
            // Normal case: project is parent of vendor
            let dirname_call = format!("dirname(__DIR__, {})", nesting_level);
            if remaining.is_empty() {
                Ok(dirname_call)
            } else {
                Ok(format!("{}.{}", dirname_call, php_var_export_string(&format!("/{}", remaining))))
            }
        }
    }

    /// Build the runtime options PHP array code.
    fn build_runtime_options(&self, extra: &serde_json::Value, project_dir_code: &str) -> String {
        let mut options = Vec::new();

        if let Some(obj) = extra.as_object() {
            for (key, value) in obj {
                // Skip 'class' and 'autoload_template' as they're not runtime options
                if key == "class" || key == "autoload_template" {
                    continue;
                }

                let value_str = php_var_export(value);
                options.push(format!("  '{}' => {},", key, value_str));
            }
        }

        // Always add project_dir
        options.push(format!("  'project_dir' => {},", project_dir_code));

        format!("[\n{}\n]", options.join("\n"))
    }
}

/// Convert a Rust string to a PHP var_export string representation.
fn php_var_export_string(s: &str) -> String {
    // Escape single quotes and backslashes
    let escaped = s.replace('\\', "\\\\").replace('\'', "\\'");
    format!("'{}'", escaped)
}

/// Convert a serde_json::Value to PHP var_export representation.
fn php_var_export(value: &serde_json::Value) -> String {
    match value {
        serde_json::Value::Null => "null".to_string(),
        serde_json::Value::Bool(b) => if *b { "true" } else { "false" }.to_string(),
        serde_json::Value::Number(n) => n.to_string(),
        serde_json::Value::String(s) => php_var_export_string(s),
        serde_json::Value::Array(arr) => {
            if arr.is_empty() {
                "[]".to_string()
            } else {
                let items: Vec<String> = arr.iter().map(php_var_export).collect();
                format!("[{}]", items.join(", "))
            }
        }
        serde_json::Value::Object(obj) => {
            if obj.is_empty() {
                "[]".to_string()
            } else {
                let items: Vec<String> = obj
                    .iter()
                    .map(|(k, v)| format!("'{}' => {}", k.replace('\'', "\\'"), php_var_export(v)))
                    .collect();
                format!("[{}]", items.join(", "))
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_php_var_export_string() {
        assert_eq!(php_var_export_string("hello"), "'hello'");
        assert_eq!(php_var_export_string("it's"), "'it\\'s'");
        assert_eq!(php_var_export_string("path\\to"), "'path\\\\to'");
    }

    #[test]
    fn test_php_var_export() {
        assert_eq!(php_var_export(&serde_json::json!(null)), "null");
        assert_eq!(php_var_export(&serde_json::json!(true)), "true");
        assert_eq!(php_var_export(&serde_json::json!(false)), "false");
        assert_eq!(php_var_export(&serde_json::json!(42)), "42");
        assert_eq!(php_var_export(&serde_json::json!("test")), "'test'");
        assert_eq!(php_var_export(&serde_json::json!([1, 2, 3])), "[1, 2, 3]");
        assert_eq!(php_var_export(&serde_json::json!({"a": 1})), "['a' => 1]");
    }

    #[test]
    fn test_calculate_project_dir_code() {
        let plugin = SymfonyRuntimePlugin;

        // Create temp directories to test
        let temp = TempDir::new().unwrap();
        let project_dir = temp.path();
        let vendor_dir = temp.path().join("vendor");
        std::fs::create_dir_all(&vendor_dir).unwrap();

        let result = plugin.calculate_project_dir_code(&vendor_dir, project_dir).unwrap();
        assert_eq!(result, "dirname(__DIR__, 1)");
    }

    #[test]
    fn test_build_runtime_options() {
        let plugin = SymfonyRuntimePlugin;

        let extra = serde_json::json!({
            "class": "SomeClass",
            "autoload_template": "template.php",
            "env_var_name": "APP_ENV",
            "debug_var_name": "APP_DEBUG"
        });

        let result = plugin.build_runtime_options(&extra, "dirname(__DIR__, 1)");

        assert!(result.contains("'env_var_name' => 'APP_ENV'"));
        assert!(result.contains("'debug_var_name' => 'APP_DEBUG'"));
        assert!(result.contains("'project_dir' => dirname(__DIR__, 1)"));
        // Should not contain class or autoload_template
        assert!(!result.contains("'class'"));
        assert!(!result.contains("'autoload_template'"));
    }
}
